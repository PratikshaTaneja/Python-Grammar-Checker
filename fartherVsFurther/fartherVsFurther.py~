
'''                                                                                                                 
Farther vs Further
Fri Dec 18 11:07:54 AEDT 2015

A simple grammar checker for this single rule. 
'''
#import nltk
from textblob import TextBlob
import csv 
from Sentence import Sentence

class WordMangle(object):
	"""Sun Dec 20 07:43:55 AEDT 2015"""
#Created a better way to find tags before and after a key.
#This new method is scalable because it can accept any number of surrounding features.
#TODO I could develop this method to collect other features like word frequencies.

	def __init__(self):
		#self.mangle = MangleData()
		pass

	def tagSentence(self, sentence):
		"""Turn a sentence into an array of (words, tags)"""
		return TextBlob(sentence).tags

	def addTags(self, sentence=[("further", "JJ"), ("Elephant", "NNP")], factors=5):	
		""""
		Buffer a list of (word, tag) with NAs of any factor
		[(x1,y1), (x2,y2)], 1 ----> [(na,na), (x1,y1), (x2,y2), (na,na)]
		"""
		newVars = []
		for i in range(factors):
			newVars.append(("na", "na"))
		sentence += newVars
		newVars += sentence
		return newVars

	def extractTags(self, sentence=[("NA","NA"),("run","VB"),("further", "JJ"), ("Elephant", "NNP"),("Hotel","NNP"),("NA","NA")], keys=["further", "farther"], factors=2):
		"""Get tags that surround a key """
		count = 0
		listOfTags = []
		for i in sentence:
			# Wait till you find one of the keys
			if i[0] in keys:
				iterNum = 0
				#Get words before key
				for z in range(factors):

					listOfTags.append(sentence[(count - factors) + iterNum][1])
					iterNum += 1
				iterNum = 1
				#Get words after key
				for z in range(factors):

					listOfTags.append(sentence[count + iterNum][1])
					iterNum += 1
				return listOfTags	
			count += 1
		return listOfTags

	def processWords(self, sentence="I can not take it much farther.", keys=["further", "farther"], factors=5):
		"""Turns a sentence into a list of words with buffer of N factors"""
		#Tag sentence
		X = self.tagSentence(sentence)
		#Add NAs to front and back
		X = self.addTags(X, factors)
		#Reduce to a list of tags
		return self.extractTags(X, keys, factors)

class CheckGrammar(object):
	"""
	Calculate Naive Bayes on any sample provided.
	This class reads Bayes data and calculates the algorithm based on this data.
	"""
	def __init__(self):
		self.mangle = MangleData()

	def quickLoop(self):
		while (True):
			x = raw_input(">> ")
			self.testSentence(x)

	def testSentence(self, sentence="You could not be further from the truth.", fileName="finalFurther.csv", class1=13086.0, class2=3861.0):
		t = self.mangle.tagSentence(sentence)
		
		X = [self.mangle.before2Status(t), self.mangle.beforeStatus(t),self.mangle.afterStatus(t),self.mangle.after2Status(t)]
		print X
		# Load training data
		Y = self.mangle.loadCSV(fileName)
		print sentence
		trueCond = class1 / (class1 + class2)
		falseCond = class2 / (class1 + class2)
		print trueCond, falseCond
		# loop over tags
		count = 1
		for z in X:
			# find tag in dataset
			for i in Y:
				if z == i[0]:
					print float(i[count]), float(i[count+1])
					trueCond *= float(i[count])
					falseCond *= float(i[count+1])
			count += 2
		print "further: " + str(trueCond / (trueCond + falseCond))
		print "farther: " + str(falseCond / (trueCond + falseCond))


class ComputeBayes(object):
	"""
	Create a CSV spreadsheet of all the Bayes data.
	"""
	#TODO create a dict of dicts to allow for more features to be dynamically added.
	def __init__(self):
		# load MangleData class
		self.feature1 = {"CC": 1, "CD": 1, "na": 1, "DT": 1, "EX": 1, "FW": 1, "IN": 1, "JJ": 1, "JJR": 1, "JJS": 1, "LS": 1, "MD": 1, "NN": 1, "NNP": 1, "NNPS": 1, "NNS": 1, "PDT": 1, "POS": 1, "PRP": 1, "PRP$": 1, "RB": 1, "RBR": 1, "RBS": 1, "RP": 1, "SYM": 1, "TO": 1, "UH": 1, "VB": 1, "VBD": 1, "VBG": 1, "VBN": 1, "VBP": 1, "VBZ": 1, "WDT": 1, "WP": 1, "WP$": 1, "WRB": 1, "total": 37}
		self.mangle = MangleData()
		#self.initDicts()

	def setupDicts(self, factors = 2):
		"""Setup feature dicts for any number of features """
		# Class 1 dict
		self.features = {}
		self.factors = factors
		factors *= 2
		for i in range(factors):
			self.features[i] = {k:v for k,v in self.feature1.items()}
		
		# Class 2 dict
		self.featuresClass2 = {}
		#factors *= 2
		for i in range(factors):
			self.featuresClass2[i] = {k:v for k,v in self.feature1.items()}

	def clearDict(self):
		"""Clears the one dict to rule them all."""
		self.features.clear()

	def countAllFeatures(self, fileName = "farther.csv"):
		"""Create a dict of feature counts"""
		self.class1Name = fileName
		X = self.mangle.loadCSV(fileName)
		# rows - intances
		for i in X:
			count = 0
			# columns - features
			for z in i:
				# Add count for each item according to column and row
				if count < (len(i) - 1): 
					self.features[count][z] += 1
					self.features[count]['total'] += 1
				count += 1

	def countAllFeaturesClass2(self, fileName = "further.csv"):
		"""Create a dict of feature counts"""
		self.class2Name = fileName
		X = self.mangle.loadCSV(fileName)
		# rows - intances
		for i in X:
			count = 0
			# columns - features
			for z in i:
				# Add count for each item according to column and row
				if count < (len(i) - 1): 
					self.featuresClass2[count][z] += 1
					self.featuresClass2[count]['total'] += 1
				count += 1

	def intersect(self, X, Y):
		"""
		Join two lists in an overlaping fashion 
		[x1, x2, x3], [y1, y2, y3] ----> [x1, y1, x2, y2, x3, y3]
		"""
		result = [None] * (len (X) + len(Y))
		result[::2] = X
		result[1::2] = Y
		return result

	def createSheet(self):
		"""Create spreadsheet of data for (features * tags)"""
		# Create header string
		# e.g. "tag,f1_c1,f1_c2,f2_c1,f2_c2,f3_c1,f3_c2,f4_c1,f4_c2"
		A = ["f" + str(x + 1) + "_c1" for x in range(self.factors * 2)]
		B = ["f" + str(x + 1) + "_c2" for x in range(self.factors * 2)]
		C = ["tags"] + self.intersect(A, B)
		print ','.join(C)
		# Loop over every tag in order
		for i in self.getTagList():
			# Get list of features for each class for each tag
			X = [str(self.features[x][i]) for x in range(self.factors * 2)]
			Y = [str(self.featuresClass2[x][i]) for x in range(self.factors * 2)]
			
			# Intersect the two lists
			Z = [i] + self.intersect(X, Y)
			print ','.join(Z)

		# Print totals for data
		print "class_1," + str(self.features[0]['total'])
		print "class_2," + str(self.featuresClass2[0]['total'])

	def getTagList(self):
		#TODO Sort tags so that they're easier to view in spreadsheet
		return ['WRB', 'PRP$', 'VBG', 'FW', 'CC', 'PDT', 'RBS', 'PRP', 'CD', 'WP$', 'VBP', 'VBN', 'EX', 'JJ', 'IN', 'WP', 'VBZ', 'DT', 'MD', 'NNPS', 'RP', 'NN', 'na', 'RBR', 'VBD', 'JJS', 'JJR', 'SYM', 'VB', 'TO', 'UH', 'LS', 'RB', 'WDT', 'NNS', 'POS', 'NNP']
			
	def printOutTags(self):
		"""Make printable version of tag names"""
		for i in self.feature1:
			print "'" + i + "',",	

class MangleData(object):
	"""
	Convert a raw corpus into a dataset.
	"""  
#TODO I've created better methods to do some of these tasks in the new class called WordMangle()
  
        def __init__(self):
		# use a dictionary to store tags e.g. {"vvb": 1, "jj": 2}
		self.mangle = WordMangle()

	#def getListOfTags(self):
		#"""Use this to get a list of all nltk tags printed 2 screen."""
		#print nltk.help.upenn_tagset()

        def tagSentence(self, sentence):
		"""Turn a sentence into an array of (words, tags)"""
		return TextBlob(sentence).tags

	def loadCSV(self, fileName="fartherVsFurther.csv"):
		"""Load training set"""
		f = open(fileName, "rb")
		reader = csv.reader(f)
		newData = []
		for line in reader:
			newData += [line]

		f.close()
		return newData

	def trainLargeCorpus(self, fileName="sentenceExamples/furtherKindleSmall.txt", factors = 2):
		"""Convert a training set to an array of values."""
		X = open(fileName, 'r').read().lower().split("\n")			
		count = 0
		for i in X:
			if len(i) < 2: 
				#count += 1
				continue

			X[count] = self.mangle.processWords(i, ["further"], factors)
			print ','.join(X[count])
			count += 1
						
def main():

	"""Step 4: Looping over examples"""
	#loopTest = CheckGrammar()
	#loopTest.quickLoop()

	"""Step 3: Check real life example"""
	#testModel = CheckGrammar()
	#testModel.testSentence("If you complain further, I'm going to shoot you out of the airlock.", "finalFurther.csv")

	"""Step 2: Compute Bayes"""
	#TODO calculate the features dynamically to allow for any number of features.
	#computeBayes = ComputeBayes()
	#computeBayes.setupDicts(2)
	#computeBayes.countAllFeatures("further.csv")
	#computeBayes.countAllFeaturesClass2("farther.csv")
	#computeBayes.createSheet()
	
	"""Step 1: Mangle Data"""
	#mangleData = MangleData()
	#mangleData.trainLargeCorpus("bookExtract/furtherGutenberg.txt", 2)

	"""Step 0: Get Data"""
	getSentences = Sentence()
	getSentences.findSentence("further", "/home/juke/prog/booksKindle")


if __name__ == '__main__':main()
